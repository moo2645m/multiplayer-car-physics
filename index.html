<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>The Dream: Red Sedan</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000; font-family: monospace; touch-action: none; user-select: none; }
        #joystick-wrapper {
            position: absolute; bottom: 40px; left: 40px; width: 100px; height: 100px;
            background: rgba(255,255,255,0.05); border: 1px solid rgba(255,255,255,0.2); border-radius: 50%;
            display: flex; align-items: center; justify-content: center; z-index: 10;
        }
        #joystick-knob { width: 40px; height: 40px; background: #ff0000; border-radius: 50%; position: absolute; pointer-events: none; }
        #brake-btn {
            position: absolute; bottom: 40px; right: 40px; width: 80px; height: 80px;
            background: rgba(255,0,0,0.1); border: 1px solid #ff0000; border-radius: 12px;
            color: #ff0000; font-weight: bold; display: flex; align-items: center; justify-content: center; z-index: 10;
        }
        #ui {
            position: absolute; top: 20px; left: 20px; color: #fff; background: rgba(0,0,0,0.9);
            padding: 12px; border-radius: 4px; font-size: 11px; border-left: 2px solid #ff0000; 
            pointer-events: none; line-height: 1.6; letter-spacing: 1px;
        }
    </style>
</head>
<body>

<div id="joystick-wrapper"><div id="joystick-knob"></div></div>
<div id="brake-btn">BRAKE</div>
<div id="ui">
    RED SEDAN | V3.5.6<br>
    SPEED: <span id="speed-val">0</span> KM/H<br>
    STEERING: STATIC WEAK (0.08)<br>
    ENGINE: 4.1e15 | MODE: STABLE
</div>

<script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.182.0/build/three.module.js",
            "three/addons/": "https://unpkg.com/three@0.182.0/examples/jsm/",
            "cannon-es": "https://unpkg.com/cannon-es@0.20.0/dist/cannon-es.js",
            "simplex-noise": "https://cdn.skypack.dev/simplex-noise@2.4.0"
        }
    }
</script>

<script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
    import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
    import * as SkeletonUtils from 'three/addons/utils/SkeletonUtils.js';
    import * as CANNON from 'cannon-es';
    import SimplexNoise from 'simplex-noise';

    const simplex = new SimplexNoise();
    const DATA_RES = 1024, GRID_SIZE = 1200, AMPLITUDE = 40, FREQ = 0.0015, WHEEL_RADIUS = 0.5; 
    const MASS = 6.8e14;
    const MAX_SPEED_KMH = 650;
    const MAX_SPEED_MS = MAX_SPEED_KMH / 3.6;

    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x000000); 
    
    const camera = new THREE.PerspectiveCamera(70, window.innerWidth/window.innerHeight, 0.1, 10000);
    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(window.devicePixelRatio);
    document.body.appendChild(renderer.domElement);

    const controls = new OrbitControls(camera, renderer.domElement);
    controls.minDistance = 8; controls.maxDistance = 20;
    
    const sun = new THREE.DirectionalLight(0xffffff, 2.5);
    sun.position.set(50, 100, 50);
    scene.add(sun, new THREE.AmbientLight(0xffffff, 0.4));

    const world = new CANNON.World();
    world.gravity.set(0, -150, 0); 
    world.solver.iterations = 60; 

    const groundMat = new CANNON.Material("ground"), carMat = new CANNON.Material("car");
    world.addContactMaterial(new CANNON.ContactMaterial(groundMat, carMat, {
        friction: 0.1, restitution: 0.0,
        contactEquationStiffness: 1e13, contactEquationRelaxation: 5
    }));

    function getHeight(x, z) { return simplex.noise2D(x * FREQ, z * FREQ) * AMPLITUDE; }

    const terrainGeo = new THREE.PlaneGeometry(GRID_SIZE, GRID_SIZE, DATA_RES - 1, DATA_RES - 1);
    terrainGeo.rotateX(-Math.PI / 2);
    const terrainMesh = new THREE.Mesh(terrainGeo, new THREE.MeshStandardMaterial({ color: 0x444444, wireframe: true }));
    scene.add(terrainMesh);

    let hfBody = null;
    const elementSize = GRID_SIZE / (DATA_RES - 1);

    function syncTerrain(cx, cz) {
        const step = GRID_SIZE / 4; 
        const snapX = Math.floor(cx / step) * step, snapZ = Math.floor(cz / step) * step;
        terrainMesh.position.set(snapX, 0, snapZ);
        const matrix = [];
        for (let i = 0; i < DATA_RES; i++) {
            matrix.push(new Float32Array(DATA_RES));
            for (let j = 0; j < DATA_RES; j++) {
                const wx = snapX - (GRID_SIZE / 2) + (i * elementSize);
                const wz = snapZ - (GRID_SIZE / 2) + (j * elementSize);
                matrix[i][DATA_RES - 1 - j] = getHeight(wx, wz);
            }
        }
        const posAttr = terrainGeo.attributes.position;
        for (let i = 0; i < posAttr.count; i++) {
            posAttr.setY(i, getHeight(posAttr.getX(i) + snapX, posAttr.getZ(i) + snapZ));
        }
        posAttr.needsUpdate = true;
        if (hfBody) world.removeBody(hfBody);
        hfBody = new CANNON.Body({ mass: 0, material: groundMat });
        hfBody.addShape(new CANNON.Heightfield(matrix, { elementSize: elementSize }));
        hfBody.quaternion.setFromEuler(-Math.PI / 2, 0, 0);
        hfBody.position.set(snapX - GRID_SIZE/2, 0, snapZ + GRID_SIZE/2);
        world.addBody(hfBody);
    }

    const chassisBody = new CANNON.Body({ mass: MASS, material: carMat });
    chassisBody.addShape(new CANNON.Box(new CANNON.Vec3(1.2, 0.4, 1.15)), new CANNON.Vec3(0, 0, 1.15));
    chassisBody.addShape(new CANNON.Box(new CANNON.Vec3(1.2, 0.4, 1.15)), new CANNON.Vec3(0, 0, -1.15));
    chassisBody.position.set(0, 20, 0);
    chassisBody.angularDamping = 0.99; 
    chassisBody.linearDamping = 0.05;

    const vehicle = new CANNON.RaycastVehicle({ chassisBody, indexForwardAxis: 2, indexRightAxis: 0, indexUpAxis: 1 });
    const wOpts = { radius: WHEEL_RADIUS, directionLocal: new CANNON.Vec3(0, -1, 0), suspensionStiffness: 500, suspensionRestLength: 1.1, frictionSlip: 50.0, dampingRelaxation: 20, dampingCompression: 15, axleLocal: new CANNON.Vec3(-1, 0, 0) };
    [[1.2, 0, 1.6], [-1.2, 0, 1.6], [1.2, 0, -1.725], [-1.2, 0, -1.725]].forEach(p => {
        wOpts.chassisConnectionPointLocal = new CANNON.Vec3(...p);
        vehicle.addWheel(wOpts);
    });
    vehicle.addToWorld(world);

    const carMesh = new THREE.Group();
    scene.add(carMesh);
    const loader = new GLTFLoader();
    loader.load('https://raw.githubusercontent.com/moo2645m/car-glb/main/scene.glb', (gltf) => {
        gltf.scene.scale.set(3, 3, 3); gltf.scene.position.set(0, -0.5, 0.2);
        carMesh.add(gltf.scene);
    });

    const wheelMeshes = [];
    loader.load('https://raw.githubusercontent.com/moo2645m/wheel-glb/main/Tire.glb', (gltf) => {
        const tireSource = gltf.scene;
        const s = WHEEL_RADIUS * 0.8;
        tireSource.scale.set(s, s, s); 
        for (let i = 0; i < 4; i++) {
            const wheelGroup = new THREE.Group();
            wheelGroup.add(SkeletonUtils.clone(tireSource));
            scene.add(wheelGroup);
            wheelMeshes[i] = wheelGroup;
        }
    });

    let drive = { throttle: 0, steer: 0, brake: false }, joyK = document.getElementById('joystick-knob'), joyW = document.getElementById('joystick-wrapper'), activePtr = null;
    joyW.onpointerdown = e => { activePtr = e.pointerId; handleJoy(e); };
    window.onpointermove = e => { if(e.pointerId === activePtr) handleJoy(e); };
    window.onpointerup = e => { if(e.pointerId === activePtr) { activePtr = null; joyK.style.transform = ''; drive.throttle = 0; drive.steer = 0; } };
    function handleJoy(e) {
        const r = joyW.getBoundingClientRect();
        let dx = e.clientX - (r.left + 50), dy = e.clientY - (r.top + 50);
        const d = Math.min(Math.sqrt(dx*dx + dy*dy), 45);
        if (d > 0) {
            const mag = Math.sqrt(dx*dx+dy*dy);
            joyK.style.transform = `translate(${(dx/mag)*d}px, ${(dy/mag)*d}px)`;
            drive.throttle = -dy/45; drive.steer = -dx/45;
        }
    }
    document.getElementById('brake-btn').onpointerdown = () => drive.brake = true;
    window.addEventListener('pointerup', () => drive.brake = false);

    const clock = new THREE.Clock(), prevPos = new THREE.Vector3();
    let lastUpdatePos = new THREE.Vector3(0,0,0), easedBrake = 0;

    function animate() {
        requestAnimationFrame(animate);
        const delta = clock.getDelta();
        const speed = vehicle.currentVehicleSpeedKmHour, absSpeed = Math.abs(speed);

        const subSteps = 30; 
        const timeStep = 1 / (60 * subSteps); 
        for (let i = 0; i < subSteps; i++) {
            world.step(timeStep);
            const v = chassisBody.velocity.length();
            if (v > MAX_SPEED_MS) {
                chassisBody.velocity.normalize();
                chassisBody.velocity.scale(MAX_SPEED_MS, chassisBody.velocity);
            }
        }

        const engineForce = (absSpeed < MAX_SPEED_KMH) ? drive.throttle * 4.1e15 : 0;
        const targetBrake = drive.brake ? (MASS * (absSpeed / 3.6)) / 2.0 : 0;
        const easeFactor = drive.brake ? 0.00005 : 0.1;
        easedBrake += (targetBrake - easedBrake) * easeFactor;

        for(let i=0; i<4; i++) {
            vehicle.applyEngineForce(engineForce, i);
            vehicle.setBrake(easedBrake / 4, i);
        }
        
        // STATIC WEAK STEERING (Locked at 0.08)
        const steerStrength = 0.08;
        vehicle.setSteeringValue(drive.steer * steerStrength, 2);
        vehicle.setSteeringValue(drive.steer * steerStrength, 3);

        carMesh.position.copy(chassisBody.position); carMesh.quaternion.copy(chassisBody.quaternion);
        vehicle.wheelInfos.forEach((w, i) => { 
            vehicle.updateWheelTransform(i); 
            if (wheelMeshes[i]) {
                wheelMeshes[i].position.copy(w.worldTransform.position); 
                wheelMeshes[i].quaternion.copy(w.worldTransform.quaternion); 
                wheelMeshes[i].children[0].rotateX((speed * delta) / WHEEL_RADIUS * 0.1 * ((i >= 2) ? -1 : 1));
            }
        });

        if (chassisBody.position.distanceTo(lastUpdatePos) > 200) { syncTerrain(chassisBody.position.x, chassisBody.position.z); lastUpdatePos.copy(chassisBody.position); }
        
        camera.fov = 70 + (absSpeed / 40); camera.updateProjectionMatrix();
        camera.position.add(new THREE.Vector3().subVectors(chassisBody.position, prevPos));
        controls.target.copy(chassisBody.position);
        prevPos.copy(chassisBody.position);
        
        document.getElementById('speed-val').innerText = Math.round(absSpeed).toLocaleString();
        
        controls.update(); renderer.render(scene, camera);
    }
    syncTerrain(0, 0); animate();
</script>
</body>
</html>
